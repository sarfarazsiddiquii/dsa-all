que 1 
# Consider telephone book database of N clients. Make use of a hash table implementation to quickly look up client’s telephone number. Make use of two collision handling techniques and compare them using number of comparisons required to find a set of telephone numbers.

import array as hashtable 
size=int(input("Enter Size of telephone book Entries:"))


hashtable=hashtable.array('i',[-1]*size)



def display():
    for i in range (0,size):
        print("Index[",i,"]=",hashtable[i],"\n") #'-1' indicates empty
       
def insert():
  
    list = input("Enter 8 digit number to insert in Telephone book:  ")
    list = list.split() #splited each value by split()
    
    for num in list:
        num = int(num)
        choice=0
        print("Which Collision Handling Technique do you want to use?")
        print("1) Linear Probing")
        print("2) Quadraic Probing")
        choice=int(input())
        #Linear Probing
        if(choice==1):
            key=num%size
            if(hashtable[key]==-1): #Insert if base address is empty
                hashtable[key]=num
            else:                 #Insert if base address is not empty
                i = (key + 1) % size
                while i != key:
                    if hashtable[i] == -1:
                        hashtable[i] = num
                        return
                    i = (i + 1) % size
                print("Hashtable Overflow")

        #Quadratic Probing
        elif(choice==2):       
            key = num % size
            if hashtable[key] == -1: #Insert if base address is empty
                hashtable[key] = num
            else:                #Insert if base address is not empty
                i = 1
                while i < size:
                    next_key = (key + i*i) % size
                    
                    if hashtable[next_key] == -1:
                        hashtable[next_key] = num
                        break
                    i += 1
                    
                    if i == size:
                        print("Hashtable Overflow")
        else:
            print("Enter Valid Input")


def delete():
     num=int(input("Enter number to delete from Telephone Book:"))
     for i in range (0,size):
       if(num==hashtable[i]):
         hashtable[i]=-1


def search():
    num = int(input("Enter number to search from telephone book:"))
    key = num % size
    i = 0
    while True:
        next_key = (key + i*i) % size
        if hashtable[next_key] == num:
            print("Number found at index", next_key)
            return
        elif hashtable[next_key] == -1 or next_key == key:
            print("Number not found in hash table")
            return
        i += 1


print("=========Telephone Book Database=========")
choice = 0
while True:
    print("******************")
    print("1) Insert        *")
    print("2) Delete        *")
    print("3) Search        *")
    print("4) Display       *")
    print("5) Exit          *")
    print("******************")
    choice = int(input())
    if choice == 1:
        insert()
    elif choice == 2:
        delete()
    elif choice == 3:
        search()
    elif choice == 4:
        display()
    elif choice == 5:
        break
    else:
        print("Enter Valid Choice")



que 2
#To create ADT that implement the “set” concept. a. Add (new Element) -Place a value into the set, b. Remove (element) Remove the value, c. Contains (element) Return true if element is in collection, d. Size () Return number of values in collection Iterator () Return an iterator used to loop over collection, e. Intersection of two sets, f. Union of two sets, g. Difference between two sets, h. Subset.

#Operations on Set
#Function for finding element from set
def contains(s):
    el1=input("Enter Element to search from Set: ")
    l1 = list(s)
    flag=1
    for i in range(len(l1)):
        if(l1[i]==el1):
            print("Element Found")
            flag=0
            break
    if(flag==1):
        print("Element Not Found")


#Two empty set initialization
s1=set()
s2=set()


print("===============Operations on Set==================")
choice = 0
while True:
    print("Enter Your Choice:")
    print("1) ADD")
    print("2) REMOVE")
    print("3) CONTAINS")
    print("4) OPERATIONS")
    print("5) DISPLAY")
    print("6) EXIT")
    choice = int(input())
    if choice == 1:
        #Add
        t=1
        while(t):
            n=int(input("Insert in Set 1 or 2:"))
            if(n==1):
                el1=input("Enter Element in Set 1: ")
                s1.add(el1)
            else:
                el2=input("Enter Element in Set 2: ")
                s2.add(el2)
            t=int(input("Press 1 to insert more: "))
    elif choice == 2:
        #remove
        n=int(input("Remove from Set 1 or 2:"))
        if(n==1):
            el1=input("Enter Element to remove from Set 1: ")
            s1.remove(el1)
        else:
            el2=input("Enter Element to remove from Set 2: ")
            s2.remove(el2)
    elif choice == 3:
        #contains
        n=int(input("Find from Set 1 or 2:"))
        if(n==1):
            contains(s1)
        elif(n==2):
            contains(s2)
        else:
            print("Enter valid Choice!")
            
    elif choice == 4:
        # union
        print("Union :", s1 | s2)
        # intersection
        print("\nIntersection :", s1 & s2)
        # difference
        print("\nDifference of Set1-Set2:", s1 - s2)
        print("Difference of Set2-Set1:", s2 - s1)
        # symmetric difference
        print("\nSymmetric difference :", s1 ^ s2)
        if(s1.issubset(s2)):
            print("\nSet 1 is Subset of Set 2")
        elif(s2.issubset(s1)):
            print("\nSet 2 is Subset of Set 1")
        else:
            print("\nBoth are Disjoint Sets")
    elif choice == 5:
        print("Set 1:",s1)
        print("Set 2:",s2)
    elif choice == 6:
        break
    else:
        print("Enter Valid Choice")


que 3

// Beginning with an empty binary search tree, Construct the binary search tree by inserting the values in the order given. After constructing a binary tree -       i. Insert new node, ii. Find number of nodes in longest path from root, iii. Minimum data value found in the tree, iv. Change a tree so that the roles of the left and right pointers are swapped at every node, v. Search a value.

#include <iostream>
using namespace std;


class node
{
public:
    node *left;
    int data;
    node *right;
};


class binary
{
public:
    node *root;
    node *temp;


    binary()
    {
        root = NULL;
    }
    void create();
    void Display();
    void inorder(node *);
    void preorder(node *);
    void postorder(node *);
    void insert(node *, node *);
    void search(node *, int key);
    void mini(node *);
    void maxi(node *);
    int longest(node *);
    void Mirror(node *);
    int DeleteNode(node *,int key);
};


void binary::create()
{
    int op;
    do
    {
        temp = new node;


        cout << "Enter the Data :";
        cin >> temp->data;


        temp->left = NULL;
        temp->right = NULL;


        if (root == NULL)
        {
            root = temp;
        }
        else
        {
            insert(root, temp);
        }
        cout << "Do you want to continue, press 1 : ";
        cin >> op;
    } while (op == 1);
}


void binary::inorder(node *root)
{
    if (root != NULL)
    {
        inorder(root->left);
        cout << root->data << " ";
        inorder(root->right);
    }
}


void binary::preorder(node *root)
{
    if (root != NULL)
    {


        cout << root->data << " ";
        preorder(root->left);
        preorder(root->right);
    }
}


void binary::postorder(node *root)
{
    if (root != NULL)
    {


        postorder(root->left);
        postorder(root->right);
        cout << " " << root->data;
    }
}


void binary::insert(node *root, node *temp)
{
    char ch;
    // cout<<"Root Node:-"<<root->data;
    if (temp->data < root->data)
    {
        if (root->left == NULL)
        {
            root->left = temp;
        }
        else
            insert(root->left, temp);
    }
    else if (temp->data > root->data)
    {


        if (root->right == NULL)
        {
            root->right = temp;
        }
        else
            insert(root->right, temp);
    }
}


void binary::search(node *root, int key)
{
    // int key;
    if (root != NULL)
    {
        if (key == root->data)
        {
            cout << "Element is Found\n";
        }
        else if (key < root->data)
        {
            search(root->left, key);
        }
        else if (key > root->data)
        {
            search(root->right, key);
        }
    }
    else
    {
        cout << "Element is not found...\n";
    }
}


void binary::mini(node *root)
{


    if (root->left == NULL)
    {
        cout << root->data;
    }
    else
    {
        return mini(root->left);
    }
}


void binary::Display()
{
    cout << "BST Traversal...";
    cout << "\nInorder Representation:";
    inorder(root);
    cout << "\nPreorder Representation:";
    preorder(root);
    cout << "\nPostorder Representation:";
    postorder(root);
}


void binary::maxi(node *root)
{
    if (root->right == NULL)
    {
        cout << root->data;
    }
    else
    {
        return maxi(root->right);
    }
}


void binary::Mirror(node *root)
{
    if (root == NULL)
    {
        return;
    }
    else
    {
        node *t;
        t = new node;
        Mirror(root->left);
        Mirror(root->right);
        t = root->left;
        root->left = root->right;
        root->right = t;
    }
}


int binary::longest(node *root)
{


    if (root == NULL)
    {
        return 0;
    }
    else
    {
        int leftt = longest(root->left);
        int rightt = longest(root->right);
        return max(leftt, rightt) + 1;
    }
}


node * DeleteNode(node* root, int key)
{
    if (root == NULL)
        return NULL;


    if (key < root->data)
        root->left = DeleteNode(root->left, key);
 
    else if (key > root->data)
        root->right = DeleteNode(root->right, key);


    else {
    //Leaf node. 
    if(root->left == NULL && root->right == NULL)
        {
            free(root);
            return NULL;
        }
    // Node has right child.
    if (root->left == NULL) {
         node *curr = root->right;
            free(root);
            return curr;
        }
        
       //Node has left child.
        else if (root->right == NULL) {
          node *curr = root->left;
            free(root);
            return curr;
        }
        
       //Node has both left and right children. 
        else
    {


      node *curr = root->right;


      while (curr->left != NULL)
        curr = curr->left;
      root->data = curr->data;
      root->right = DeleteNode(root->right,curr->data);
}


 }
  return root;
}
int main()
{
    binary nd;
    int key, ch;


    while (1)
    {
        cout << "\n1) Create and insert node in BST\n2)Traversal Tree\n3)Search element from BST\n4)Find Min element\n5)Find Max element\n6)Mirror Tree\n7)Longest Path\n8)Delete node\n9)Exit\n";
        cout << "\nEnter your choice:";
        cin >> ch;
        switch (ch)
        {
        case 1:
            nd.create();
            break;


        case 2:
            nd.Display();
            break;


        case 3:
            cout << "\nSearch Operation on BST..\n";
            cout << "Enter Element to Search:";
            cin >> key;
            nd.search(nd.root, key);
            break;


        case 4:
            cout << "\nMin element:";
            nd.mini(nd.root);
            break;


        case 5:
            cout << "\nMax element:";
            nd.maxi(nd.root);
            break;


        case 6:
            cout << "\nMirror Image of Tree:";
            nd.Mirror(nd.root);
            nd.Display();
            break;


        case 7:
            cout << "\nLongest Path:\n";
            cout << "Height= " << nd.longest(nd.root);
            break;
        case 8:
            cout<<"\nDelete Operation on BST..\n";
            cout<<"Enter Element to Search for Delete:";
            cin>>key;
            DeleteNode(nd.root,key);
            break;
            


        case 9:
            cout << "Thank you...!!";
            break;


        default:
            cout << "Invalid choice..\n";
        }
    }
    return 0;
}

que 4

//Construct an expression tree from the given prefix expression eg. +--a*bc/def and traverse it using post order traversal (non-recursive) and then delete the entire tree.

// Expression Tree
#include <iostream>
#include <stack>
#include <string>
using namespace std;
class node
{
public:
    node *right;
    node *left;
    node *root;
    char data;
    node(char data, node *left, node *right)
    {
        this->data = data;
        this->left = left;
        this->right = right;
    }
    node(char data)
    {
        this->data = data;
    }
    node()
    {
        root = NULL;
    }
};
bool isOperator(char c)
{
    return (c == '+' || c == '-' || c == '*' || c == '/' || c == '^');
}
void postorder(node *root)


{
    if (root != NULL)
    {
        postorder(root->left);
        postorder(root->right);
        cout << " " << root->data;
    }
}
void inorder(node *root)
{
    if (root == NULL)
    {
        return;
    }
    if (isOperator(root->data))
    {
        cout << "(";
    }
    inorder(root->left);
    cout << root->data;
    inorder(root->right);
    if (isOperator(root->data))
    {
        cout << ")";
    }
}
node *exptree(string postfix)
{
    if (postfix.length() == 0)
    {


        return NULL;
    }
    // create an empty stack to store tree pointers
    stack<node *> s;
    // traverse the postfix exp
    for (char c : postfix)
    {
        if (isOperator(c))
        {
            node *x = s.top();
            s.pop();
            node *y = s.top();
            s.pop();
            node *nod = new node(c, y, x);
            s.push(nod);
        }
        else
        {
            s.push(new node(c));
        }
    }
    return s.top();
}
int main()
{
    // string postfix = "ab+cde+**";
    string postfix;
    cout << "Enter the expression:";
    cin >> postfix;
    node *root = exptree(postfix);
    cout << "Postfix Expression: ";
    postorder(root);
    cout << "\nInfix Expression: ";
    inorder(root);
    cout << "\n";
    return 0;
}

que 5

// A Dictionary stores keywords and its meanings. Provide facility for adding new keywords, deleting keywords, updating values of any entry. Provide facility to display whole data sorted in ascending/ Descending order. Also find how many maximum comparisons may require for finding any keyword. Use Binary Search Tree for implementation.

//BST Dictionary 
#include <iostream>
#include <string>


using namespace std;
string key;
int flag = 0;
class node
{


public:
    node *left;
    string wdata, mean;
    node *right;
};


class binary
{
public:
    node *root;
    node *temp;


    binary()
    {
        root = NULL;
    }
    void create();
    void insert(node *, node *);
    void Display();
    void ascending(node *);
    void descending(node *);
    void search(node *, string key);
    void update(node *, string key);
    int DeleteNode(node *, string key);
};


// Create Dictionary
void binary::create()
{
    int op;
    do
    {
        temp = new node;


        cout << "Enter the word :";
        cin >> temp->wdata;
        cout << "Enter the Meaning of word :";
        cin >> temp->mean;
        temp->left = NULL;
        temp->right = NULL;


        if (root == NULL)
        {
            root = temp;
        }
        else
        {
            insert(root, temp);
        }
        cout << "Do you want to continue, press 1 : ";
        cin >> op;
    } while (op == 1);
}


// Insert in Dictionary
void binary::insert(node *root, node *temp)
{
    char ch;
    // cout<<"Root Node:-"<<root->data;
    if (temp->wdata < root->wdata)
    {
        if (root->left == NULL)
        {
            root->left = temp;
        }
        else
            insert(root->left, temp);
    }
    else if (temp->wdata > root->wdata)
    {


        if (root->right == NULL)
        {
            root->right = temp;
        }
        else
            insert(root->right, temp);
    }
}


// Display Dictionary
void binary::Display()
{
    cout << "=============Dictionary===============";
    cout << "\nAscending :\n";
    ascending(root);
    cout << "\nDescending :\n";
    descending(root);
}
// Ascending Order
void binary::ascending(node *root)
{
    if (root != NULL)
    {
        ascending(root->left);
        cout << "Word:" << root->wdata << "   Meaning:" << root->mean << "\n";
        ascending(root->right);
    }
}
// Decending Order
void binary::descending(node *root)
{
    if (root != NULL)
    {
        descending(root->right);
        cout << "Word:" << root->wdata << "   Meaning:" << root->mean << "\n";
        descending(root->left);
    }
}
// Search meaning by word
void binary::search(node *root, string key)
{


    if (root != NULL)
    {


        if (key == root->wdata)
        // if(key.compare(root->wdata))


        {
            cout << "---------------Word Found------------\n";
            cout << "Word:" << root->wdata << " Meaning:" << root->mean << "\n";
        }
        else if (key < root->wdata)
        {
            search(root->left, key); // Traverse to left
        }
        else if (key > root->wdata)
        {
            search(root->right, key); // Traverse to right
        }
    }


    else
    {
        cout << "--------Word not Found----------\n";
    }
}


// Update Word meaning in dictionary
void binary::update(node *root, string key)
{


    if (root != NULL)
    {


        if (key == root->wdata)
        // if(key.compare(root->wdata))


        {
            cout << "\nEnter New Meaning of Keyword:";
            cin >> root->mean;
            cout << "Word:" << root->wdata << " Meaning:" << root->mean << "\n";
            flag = 1;
        }
        else if (key < root->wdata)
        {
            update(root->left, key);
        }
        else if (key > root->wdata)
        {
            update(root->right, key);
        }
    }
    else
    {
        cout << "Element is not found...\n";
    }
}


node *DeleteNode(node *root, string key)
{
    if (root == NULL)
        return NULL;


    if (key < root->wdata)
        root->left = DeleteNode(root->left, key);


    else if (key > root->wdata)
        root->right = DeleteNode(root->right, key);


    else
    {
        // Leaf node.
        if (root->left == NULL && root->right == NULL)
        {
            free(root);
            return NULL;
        }


        // Node has right child.
        if (root->left == NULL)
        {
            node *curr = root->right;
            free(root);
            return curr;
        }


        // Node has left child.
        else if (root->right == NULL)
        {
            node *curr = root->left;
            free(root);
            return curr;
        }


        // Node has both left and right children.
        else
        {


            node *curr = root->right;


            while (curr->left != NULL)
                curr = curr->left;
            root->wdata = curr->wdata;
            root->right = DeleteNode(root->right, curr->wdata);
        }
    }
    return root;
}
int main()
{
    binary nd;
    int ch;


    while (1)
    {
        cout << "=============Dictionary Using BST===============";
        cout << "\n1)Insert\n2)Display\n3)Search\n4)Update\n5)Delete\n6)Exit";
        cout << "\nEnter your choice:";
        cin >> ch;
        switch (ch)
        {
        case 1:
            nd.create();
            break;


        case 2:
            nd.Display();
            break;


        case 3:
            cout << "Enter word to search meaning: ";
            cin >> key;
            nd.search(nd.root, key);
            break;


        case 4:
            cout << "\nEnter a word to update meaning: ";
            cin >> key;
            nd.update(nd.root, key);
            break;


        case 5:
            cout << "\nEnter a word to delete: ";
            cin >> key;
            DeleteNode(nd.root, key);
            break;


        case 6:
            cout << "Thank you...!!";
            break;


        default:
            cout << "Invalid choice..\n";
        }
    }
    return 0;
}

que 6
//  There are flight paths between cities. If there is a flight between City A and City B then there is an edge between the cities. The cost of the edge can be the time that flight take to reach city B from A, or the amount of fuel used for the journey. Represent this as a graph. The node can be represented by the airport name or name of the city. Use adjacency list representation of the graph or use adjacency matrix representation of the graph.

#include<iostream>
#include<string.h>
using namespace std;
class flight
{ 	 
	public:
		int am[10][10];
           	char city_index[10][10];
		flight();
	   	int create();
	   	void display(int city_count);
            
};
flight::flight()
{
	int i,j;
	for(i=0;i<10;i++)
	{
		strcpy(city_index[i],"xx");
	}
	for(i=0;i<10;i++)
	{
		for(j=0;j<10;j++)
		{
			am[i][j]=0;
		}
	}
}
int flight::create()
{
	int city_count=0,j,si,di,wt;
	char s[10],d[10],c;
	do
	{
		cout<<"\n\tEnter Source City      : ";
		cin>>s;
		cout<<"\n\tEnter Destination City : ";
		cin>>d;
		for(j=0;j<10;j++)
		{
				if(strcmp(city_index[j],s)==0)
					break;
		}
		if(j==10)
		{
			strcpy(city_index[city_count],s);
				city_count++;
		}

		for(j=0;j<10;j++)
		{
				if(strcmp(city_index[j],d)==0)
					break;
		}

		if(j==10)
		{
			strcpy(city_index[city_count],d);
				city_count++;
		}

		cout<<"\n\t Enter Distance From "<<s<<" And "<<d<<": ";
		cin>>wt;
		for(j=0;j<10;j++)
		{
				if(strcmp(city_index[j],s)==0)
					si=j;
				if(strcmp(city_index[j],d)==0)
					di=j;
		}
		am[si][di]=wt;
		cout<<"\n\t Do you want to add more cities.....(y/n) : ";
		cin>>c;	
	}while(c=='y'||c=='Y');
 return(city_count);
}

void flight::display(int city_count)
{
	int i,j;
	cout<<"\n\t Displaying Adjacency Matrix :\n\t";
	for(i=0;i<city_count;i++)
		cout<<"\t"<<city_index[i];
	cout<<"\n";

	for(i=0;i<city_count;i++)
	{
		cout<<"\t"<<city_index[i];
		for(j=0;j<city_count;j++)
		{
		  cout<<"\t"<<am[i][j];	
		}
		cout<<"\n";
	}
}

int main()
{
	flight f;
	int n,city_count;
	char c;
	do
	{
		cout<<"\n\t***** Flight Main Menu *****";
		cout<<"\n\t1. Create \n\t2. Adjacency Matrix\n\t3. Exit";
		cout<<"\n\t.....Enter your choice : ";
		cin>>n;
		switch(n)
		{
			case 1:
					city_count=f.create();
					break;
			case 2:
					f.display(city_count);
					break;
			case 3:
					return 0;
		}
		cout<<"\n\t Do you Want to Continue in Main Menu....(y/n) : ";
		cin>>c;
	}while(c=='y'||c=='Y');
	return 0;
}

que 7
// You have a business with several offices; you want to lease phone lines to connect them up with each other; and the phone company charges different amounts of money to connect different pairs of cities. You want a set of lines that connects all your offices with a minimum total cost. Solve the problem by suggesting appropriate data structures.
#include <iostream>
using namespace std;
int cost[20][20];               //matrix declared as global variable
class graph
{
    int i,j,v,w,k;
public:
    graph()            //constructor
    {

        for(i=1;i<=20;i++)           //iterates from 1 to 20 and represents the rows of the cost matrix
            for(j=1;j<=20;j++)      //iterates from 1 to 20 and represents the columns of the cost matrix
                cost[i][j]=0;                 // initializes all elements of the cost matrix to zero using nested for loops
    }
    void create();
    void display();
    void prims();
};
int main() {
    graph g;
    cout<<"\n CREATE MST";
    g.create();
    g.display();
    g.prims();
    return 0;
}

void graph::create()                                         //function is used to create graph 
{
  cout<<"\n Enter total number of vertices/Houses in a lane:";    //asks user to enter the total number of vertices(houses) in the lane 
    cin>>v;                  //and storing the value in the variable v

    for(i=1;i<=v;i++)			//iterates from 1 to v & represents the starting vertex of an edge
        for(j=i+1;j<=v;j++)     // represents the ending vertex of an edge & starting from 'i+1' means each pair of vertices are visited once 
        {
            cout<<"\n Press 0 if no edge or provide cost if edge between"<<i<<"and"<<j;
            cin>>w;
     cost[i][j]=cost[j][i]=w;           //assigns cost entered by user to matrix & ensures cost from vertex i-j is same as j-i
        }
}

void graph::display()
{
    cout<<"\n Adjacency Matrix is:";
    for(i=1;i<=v;i++)  //iterates from 1 to v and represents the rows of the adjacency matrix
    {
		cout<<"\n";   //move to a new line before printing the elements of the next row
            for(j=1;j<=v;j++)    //iterates from 1 to v. It represents the columns of the adjacency matrix
            {
                cout<<"\t"<<cost[i][j];  //prints the value of edge between vertices i-j
            }
    }
}


void graph::prims()
{
    int pos=1,mincost=0,min=9999,row=0,col=0;
    int visit[20];	                 // visit and path arrays declared to track visited vertices & the selected path in the Minimum Spanning Tree
    int path[20];   
    for(i=1;i<=v;i++)
    {
        visit[i]=0;   //set to 0
        path[i]=0;
    }

    visit[1]=1;    //set to 1 saying that vertex 1 is visited and included in the MST
    path[pos++]=1; //indicates position in 'path' array

    cout<<"\n INITIALLY MINIMUM COST IS "<<mincost;        //'mincost' displayed as initial minimum cost
    for(k=1;k<=v-1;k++)    
    {
        min=999;  //
        for(i=1;i<=v;i++)    //used to check each pair of vertices
        {
            for(j=1;j<=v;j++)   //used to check each pair of vertices
            {
                if(visit[i]==1 && visit[j]==0)   //1 indicates that 'i' vertex visited once & 'j' unvisited 
                {
                    if(cost[i][j]!=0 && min>cost[i][j])
                    {
                        min=cost[i][j];   
                        row=i;
                        col=j;
                    }
                }
            }
        }
        mincost=mincost+min; //
        visit[col]=1;
        path[pos++]=col;
        cost[row][col]=cost[col][row]=0;
    }
    cout<<"\n Total minimum cost:"<<mincost;
    cout<<"\n Shortest Path is \n";
    for(i=1;i<=v;i++)
                cout<<" "<<path[i];
}

que 8
//A Dictionary stores keywords and its meanings. Provide facility for adding new keywords, deleting keywords, updating values of any entry. Provide facility to display whole data sorted in ascending/ Descending order. Also find how many maximum comparisons may require for finding any keyword. Use Height balance tree and find the complexity for finding a keyword.
//Height balance tree 

#include<iostream>
#include<string.h>
using namespace std;
class dict
{
    dict *root,*node,*left,*right,*tree1;
    string s1,s2;
    int flag,flag1,flag2,flag3,cmp;
public:
    dict()
    {
        flag=0,flag1=0,flag2=0,flag3=0,cmp=0;
        root=NULL;
    }
    void input();
    void create_root(dict*,dict*);
    void check_same(dict*,dict*);
    void input_display();
    void display(dict*);
    void input_remove();
    dict* remove(dict*,string);
    dict* findmin(dict*);
    void input_find();
    dict* find(dict*,string);
    void input_update();
    dict* update(dict*,string);
   
};

		void dict::input()
		{
			   node=new dict;
			   cout<<"\nEnter the keyword:\n";
			   cin>>node->s1;
			   cout<<"Enter the meaning of the keyword:\n";
			   cin.ignore();
			   getline(cin,node->s2);
			   create_root(root,node);
		}


				void dict::create_root(dict *tree,dict *node1)
				{
				    int i=0,result;
				    char a[20],b[20];
				    if(root==NULL)
				    {
				        root=new dict;
				        root=node1;
				        root->left=NULL;
				        root->right=NULL;
				        cout<<"\nRoot node created successfully"<<endl;
				        return;
				    }
				    for(i=0;node1->s1[i]!='\0';i++)
				    {
				    	a[i]=node1->s1[i];
				    }
				    for(i=0;tree->s1[i]!='\0';i++)
				    {
				    	b[i]=tree->s1[i];
				    }
				    result=strcmp(b,a);
				    check_same(tree,node1);
				    if(flag==1)
				        {
				            cout<<"The word you entered already exists.\n";
				            flag=0;
				        }
				        else
				        {
				    if(result>0)
				    {
				        if(tree->left!=NULL)
				        {
				            create_root(tree->left,node1);
				        }
				        else
				        {
				            tree->left=node1;
				            (tree->left)->left=NULL;
            				    (tree->left)->right=NULL;
            				cout<<"Node added to left of "<<tree->s1<<"\n";
            				return;
 				       }				
    				    }
    				    else if(result<0)
    				    {
        				 if(tree->right!=NULL)
        				 {
        				     create_root(tree->right,node1);
        				 }
        				 else
        				 {
        				     tree->right=node1;
        				     (tree->right)->left=NULL;
        				     (tree->right)->right=NULL;
        				     cout<<"Node added to right of "<<tree->s1<<"\n";
        				     return;
        				 }
    				    }			
    				         }
				    }


void dict::check_same(dict *tree,dict *node1)
{
	if(tree->s1==node1->s1)
	{
		flag=1;
		return;
	}
	else if(tree->s1>node1->s1)
     {
	 if(tree->left!=NULL)
	{
    	 check_same(tree->left,node1);
	}
     }
     else if(tree->s1<node1->s1)
     {
    	 if(tree->right!=NULL)
    	 {
    	 check_same(tree->right,node1);
    	 }
     }
}
		

		void dict::input_display()
		{
			if(root!=NULL)
			{
		    	cout<<"The words entered in the dictionary are:\n\n";
		    	display(root);
			}
			else
			{
		        cout<<"\nThere are no words in the dictionary.\n";
			}
		}
		

				void dict::display(dict *tree)
				{
				    	if(tree->left==NULL&&tree->right==NULL)
				    	{
				    		cout<<tree->s1<<" = "<<tree->s2<<"\n\n";
				    	}
				    	else
				    	{
				        if(tree->left!=NULL)
				        {
				        	display(tree->left);
				        }
				        cout<<tree->s1<<" = "<<tree->s2<<"\n\n";
				        if(tree->right!=NULL)
				        {
				        	display(tree->right);
				        }
				    	}
				}


void dict::input_remove()
{
	char t;
	if(root!=NULL)
	{
	  cout<<"\nEnter a keyword to be deleted:\n";
	  cin>>s1;
	  remove(root,s1);
	  if(flag1==0)
	  {
	    	cout<<"\nThe word '"<<s1<<"' has been deleted.\n";
	  }
	  flag1=0;
	}
	else
	{
		cout<<"\nThere are no words in the dictionary.\n";
	}
}


		dict* dict::remove(dict *tree,string s3)
		{
			dict *temp;
		    if(tree==NULL)
		    {
		    	cout<<"\nWord not found.\n";
		    	flag1=1;
		    	return tree;
		    }
		    else if(tree->s1>s3)
		    {
		    	tree->left=remove(tree->left,s3);
		    	return tree;
		    }
		    else if(tree->s1<s3)
			    {
		    	tree->right=remove(tree->right,s3);
		    	return tree;
		    }
		    else
		    {
		    	if(tree->left==NULL&&tree->right==NULL)
		    	{
		    		delete tree;
		    		tree=NULL;
		    	}
		    	else if(tree->left==NULL)
		    	{
		    		temp=tree;
		    		tree=tree->right;
		    		delete temp;
		    	}
		    	else if(tree->right==NULL)
		    	{
		    		temp=tree;
		    		tree=tree->left;
		    		delete temp;
    			}		
    			else
    			{
    				temp=findmin(tree->right);
    				tree=temp;
    				tree->right=remove(tree->right,temp->s1);
    			}
    		}
    		return tree;
		}


				dict* dict::findmin(dict *tree)
				{
					while(tree->left!=NULL)
					{
						tree=tree->left;
					}
					return tree;
				}		


		void dict::input_find()
		{
			flag2=0,cmp=0;
			if(root!=NULL)
			{
			cout<<"\nEnter the keyword to be searched:\n";
			cin>>s1;
		    find(root,s1);
		    if(flag2==0)
		    {
				cout<<"Number of comparisons needed: "<<cmp<<"\n";
				cmp=0;
		    }
			}
			else
			{
				cout<<"\nThere are no words in the dictionary.\n";
			}
		}


				dict* dict::find(dict *tree,string s3)
				{
					if(tree==NULL)
					{
						cout<<"\nWord not found.\n";
						flag2=1;
						flag3=1;
						cmp=0;
					}
					else
					{
						if(tree->s1==s3)		
						{			
							cmp++;
							cout<<"\nWord found.\n";
							cout<<tree->s1<<": "<<tree->s2<<"\n";
							tree1=tree;
							return tree;
						}
						else if(tree->s1>s3)
						{
							cmp++;
							find(tree->left,s3);
						}
						else if(tree->s1<s3)
						{
							cmp++;
							find(tree->right,s3);
						}
					}		
					return tree;
	                        }


void dict::input_update()
{
	if(root!=NULL)
	{
	cout<<"\nEnter the keyword to be updated:\n";
	cin>>s1;
    update(root,s1);
	}
	else
	{
		cout<<"\nThere are no words in the dictionary.\n";
	}
}


		dict* dict::update(dict *tree,string s3)
		{
			flag3=0;
			find(tree,s3);
			if(flag3==0)
			{
		    cout<<"\nEnter the updated meaning of the keyword:\n";
		    cin.ignore();
		    getline(cin,tree1->s2);
		    cout<<"\nThe meaning of '"<<s3<<"' has been updated.\n";
			}
		    return tree;
		}
				int main()
				  {
				    int ch;
				    dict d;
				    do
				    {
				    cout<<"\n==========================================\n"
				    	  "\n********DICTIONARY***********:\n"
    	 				 "\nEnter your choice:\n"
         				 "1.Add new keyword.\n"
         				 "2.Display the contents of the Dictionary.\n"
    	 				 "3.Delete a keyword.\n"
    	 				 "4.Find a keyword.\n"
    	 				 "5.Update the meaning of a keyword.\n"
    	 				 "6.Exit.\n"
    	 				 "===============================================\n";
    				cin>>ch;
    				switch(ch)
    				{
    				    case 1:d.input();
    				           break;
    				    case 2:d.input_display();
    				    	   break;
    				    case 3:d.input_remove();
    				           break;
    				    case 4:d.input_find();
    				           break;
    				    case 5:d.input_update();
    				    	   break;
    				    default:cout<<"\nPlease enter a valid option!\n";
    				    	    break;
    				}
    				  }while(ch!=6);
    				return 0;
                  }


que 9

// Given sequence k = k1<k2< … kn of n sorted keys, with a search probability pi for each key ki. Build the Optimal Binary search tree that has the least search cost given the access probability for each key?
#include<iostream>
using namespace std;
void con_obst(void);
void print(int,int);
float a[20],b[20],wt[20][20],c[20][20];
int r[20][20],n;
int main()
  {
	int i;
	cout<<"\n****** PROGRAM FOR OBST ******\n";
	cout<<"\nEnter the no. of nodes : ";
	cin>>n;cout<<"\nEnter the probability for successful search :: ";
	cout<<"\n————————————————\n";
	for(i=1;i<=n;i++)
	  {
		cout<<"p["<<i<<"]";
		cin>>a[i];
	  }
	cout<<"\nEnter the probability for unsuccessful search :: ";
	cout<<"\n————————————————–\n";
	for(i=0;i<=n;i++)
	  {
		cout<<"q["<<i<<"]";
		cin>>b[i];
	  }
	con_obst();
	print(0,n);
	cout<<endl;
}
void con_obst(void)
{
	int i,j,k,l,min;
	for(i=0;i<n;i++)
	  { //Initialisation
		c[i][i]=0.0;
		r[i][i]=0;
		wt[i][i]=b[i];
		// for j-i=1 can be j=i+1
		wt[i][i+1]=b[i]+b[i+1]+a[i+1];
		c[i][i+1]=b[i]+b[i+1]+a[i+1];
		r[i][i+1]=i+1;
	  }
	c[n][n]=0.0;
	r[n][n]=0;
	wt[n][n]=b[n];
	//for j-i=2,3,4....,n
	for(i=2;i<=n;i++)
	  {
		for(j=0;j<=n-i;j++)
		  {
			wt[j][j+i]=b[j+i]+a[j+i]+wt[j][j+i-1];
			c[j][j+i]=9999;
			for(l=j+1;l<=j+i;l++)
			  {
				if(c[j][j+i]>(c[j][l-1]+c[l][j+i]))
				  {
					c[j][j+i]=c[j][l-1]+c[l][j+i];
					r[j][j+i]=l;
				  }
			  }
			c[j][j+i]+=wt[j][j+i];
		  }
		cout<<endl;
	  }
	cout<<"\n\nOptimal BST is :: ";
	cout<<"\nw[0]["<<n<<"] :: "<<wt[0][n];
	cout<<"\nc[0]["<<n<<"] :: "<<c[0][n];
	cout<<"\nr[0]["<<n<<"] :: "<<r[0][n];
  }
void print(int l1,int r1)
  {
	if(l1>=r1)
		return;
	if(r[l1][r[l1][r1]-1]!=0)
		cout<<"\n Left child of "<<r[l1][r1]<<" :: "<<r[l1][r[l1][r1]-1];
	if(r[r[l1][r1]][r1]!=0)
		cout<<"\n Right child of "<<r[l1][r1]<<" :: "<<r[r[l1][r1]][r1];
	print(l1,r[l1][r1]-1);
	print(r[l1][r1],r1);
	return;
}

que 10

// Consider a scenario for Hospital to cater services to different kinds of patients as Serious (top priority), b) non-serious (medium priority), c) General Checkup (Least priority). Implement the priority queue to cater services to the patients.

#include<iostream>
#include<string>

#define N 20

#define SERIOUS 10
#define NONSERIOUS 5
#define CHECKUP 1

using namespace std;
string Q[N];
int Pr[N];
int r = -1,f = -1;
void enqueue(string data,int p)//Enqueue function to insert data and its priority in queue
{
	int i;
	if((f==0)&&(r==N-1)) //Check if Queue is full
		cout<<"Queue is full";
	else {
		if(f==-1) { //if Queue is empty
			f = r = 0;
			Q[r] = data;
			Pr[r] = p;

		}
		else if(r == N-1) { //if there there is some elemets in Queue
			for(i=f;i<=r;i++) { 
                                Q[i-f] = Q[i]; 
                                Pr[i-f] = Pr[i];
                                r = r-f; 
                                f = 0;
                                for(i = r;i>f;i--) {
					if(p>Pr[i]) {
						Q[i+1] = Q[i];
						Pr[i+1] = Pr[i];
					}
					else break;
						
					Q[i+1] = data;
					Pr[i+1] = p;
					r++;
				}
			}
		}
		else {
			for(i = r;i>=f;i--) {
				if(p>Pr[i]) {
					Q[i+1] = Q[i];
					Pr[i+1] = Pr[i];	
				}
				else break;
			}
			Q[i+1] = data;
			Pr[i+1] = p;
			r++;
		}	
	}

}
void print() { //print the data of Queue
	int i;
	for(i=f;i<=r;i++) {
		cout << "Patient's Name - "<<Q[i];
		switch(Pr[i]) {
			case 1: 
				cout << " Priority - 'Checkup' " << endl;
			break;
			case 5:
				cout << " Priority - 'Non-serious' " << endl;
			break;
			case 10:
				cout << " Priority - 'Serious' " << endl;
			break;
			default:
				cout << "Priority not found" << endl;
		}
	}
}

void dequeue() { //remove the data from front
	if(f == -1) {
		cout<<"Queue is Empty";
	}	
	else {
	cout<<"deleted Element ="<<Q[f]<<endl;
	cout<<"Its Priority = "<<Pr[f]<<endl;
		if(f==r) f = r = -1;
		else f++;
	}
}

int main() {
	string data;
	int opt,n,i,p;
	cout<<"Enter Your Choice:-"<<endl;
	do {
	cout << "1 for Insert the Data in Queue" << endl << "2 for show the Data in Queue " << endl << "3 for Delete the data from the Queue" 
		<< endl << "0 for Exit"<< endl;
	cin >> opt;
		switch(opt) {
			case 1:
				cout << "Enter the number of patinent" << endl;
				cin >> n;
				i = 0;
				while(i < n) {
					cout << "Enter your name of the patient : ";
					cin >> data;
					ifnotdoagain: 
						cout << "Enter your Prioritys (0: serious, 1: non-serious, 2: genral checkup) : ";
						cin >> p;
						switch(p) {
							case 0: 
								enqueue(data,SERIOUS);
							break;
							case 1: 
								enqueue(data,NONSERIOUS);
							break;
							case 2: 
								enqueue(data,CHECKUP);
							break;
							default:
								goto ifnotdoagain;
						}
						
					i++;
				}
			break;
			case 2:
				print();
			break;
			case 3:
				 dequeue();
			break;
			case 0:
				cout << "Bye Bye !" << endl;
			break;
			default:
			cout<<"Incorrect Choice"<<endl;

		}
	}while(opt!=0);
        return 0;
}

que 11

//: Department maintains a student information. The file contains roll number, name, division and address. Allow user to add, delete information of student. Display information of particular employee. If record of student does not exist an appropriate message is displayed. If it is, then the system displays the student details. Use sequential file to main the data
#include <iostream>
#include <fstream>
#include <cstdlib>
using namespace std;
class Student
{
public:
int rollno;
char name[20];
char dv;
void get()
{
	 	 cout<<"Enter name: ";
	 	 cin>>name;
	 	 cout<<"Enter roll no.: ";
	 	 cin>>rollno;
	 	 cout<<"Enter division: ";
	 	 cin>>dv;
}
void put()
{
	 	 cout<<"Name: "<<name<<endl;
	 	 cout<<"Roll No.: "<<rollno<<endl;
	 	 cout<<"Division: "<<dv<<endl;
}
int getroll()
{
	 	 return rollno;
}
};
void write_record()
{
ofstream outFile;
Student obj;
outFile.open("student.dat", ios::binary | ios::app);
obj.get();
outFile.write((char*)&obj, sizeof(obj));
outFile.close();
}
void display_record()
{
ifstream inFile;
Student obj;
inFile.open("student.dat", ios::binary);
while(inFile.read((char*)&obj, sizeof(obj)))
 {
 obj.put();
 }
inFile.close();
}
void search_record(int n)
{
ifstream inFile;
Student obj;
inFile.open("student.dat", ios::binary);
while(inFile.read((char*)&obj, sizeof(obj)))
{
	 	 if(obj.getroll() == n)
	 	 {
	 	 	 obj.put();
	 	 	 break;
	 	 }
}
inFile.close();
}
void delete_record(int n)
{
Student obj;
ifstream inFile;
inFile.open("student.dat", ios::binary);
ofstream outFile;
outFile.open("temp.dat", ios::binary | ios::out);
while(inFile.read((char*)&obj, sizeof(obj)))
{
	 	 if(obj.getroll() != n)
	 	 	 outFile.write((char*)&obj, sizeof(obj));
}
inFile.close();
outFile.close();
remove("student.dat");
rename("temp.dat", "student.dat");
}
void modify_record(int n)
{
fstream file;
file.open("student.dat", ios::in | ios::out);
Student obj;
while(file.read((char*)&obj, sizeof(obj)))
{
	 	 if(obj.getroll() == n)
	 	 {
	 	 	 cout<<"Enter new details: ";
	 	 	 obj.get();
	 	 	 int pos = -1*sizeof(obj);
			 file.seekp(pos,ios::cur);
			 file.write((char*)&obj, sizeof(obj));
	 	 }
}
file.close();
}
int main()
{
int ch, n;
while(true)
{
	 	 cout<<"1. Write"<<endl;
	 	 cout<<"2. Display"<<endl;
	 	 cout<<"3. Search"<<endl;
	 	 cout<<"4. Delete"<<endl;
	 	 cout<<"5. Modify"<<endl;
	 	 cout<<"6. Exit"<<endl;
	 	 cout<<"Enter your choice: ";
	 	 cin>>ch;
	 	 switch(ch)
	 	 {
	 	 	 case 1: cout<<"Enter no. of records: ";
	 	 	 cin>>n;
	 	 	 for(int i=0; i<n; i++)
	 	 	 	 write_record();
	 	 	 break;
	 	 	 case 2: display_record(); break;
	 	 	 case 3: cout<<"Enter roll no.: ";
	 	 	 cin>>n;
	 	 	 search_record(n);
	 	 	 break;
	 	 	 case 4: cout<<"Enter roll no.: ";
	 	 	 cin>>n;
	 	 	 delete_record(n);
	 	 	 break;
	 	 	 case 5: cout<<"Enter roll no.: ";
	 	 	 cin>>n;
	 	 	 modify_record(n);
	 	 	 break;
	 	 	 case 6: exit(1); break;
	 	
}
}
return 0;
}

que 12

// Company maintains employee information as employee ID, name, designation and salary. Allow user to add, delete information of employee. Display information of particular employee. If employee does not exist an appropriate message is displayed. If it is, then the system displays the employee details. Use index sequential file to maintain the data.
#include <iostream>
#include <fstream>
using namespace std;

class Record {
    int id;
    string name;
    int salary;
    string designation;

public:
    Record();
    int getIdno();
    void getData();
    void putData();
};

Record::Record() {
    id = 0;
    name = ' ';
    designation = ' ';
    salary = 0;
}

int Record::getIdno() {
    return (id);
}

void Record::getData() {
    cout << "\nEnter Details: ";
    cout << "\nId no: ";
    cin >> id;
    cout << "Name: ";
    cin >> name;
    cout << "Salary: ";
    cin >> salary;
    cout << "Designation: ";
    cin >> designation;
}

void Record::putData() {
    cout << "\nId No.: ";
    cout << id;
    cout << "\t\tName: ";
    cout << name;
    cout << "\nSalary: ";
    cout << salary;
    cout << "\tDesignation: ";
    cout << designation;
}

class File {
    ifstream fin;
    ofstream fout;
    fstream fs;

public:
    void insert();
    void display();
    void search(int);
    int Delete(int);
    int edit(int);
};

void File::insert() {
    Record r;
    r.getData();
    fout.open("EmployeeDB", ios::ate | ios::app);
    fout.write((char *)&r, sizeof(r));
    fout.close();
}

void File::display() {
    Record r;
    fin.open("EmployeeDB");
    fin.seekg(0, ios::beg);
    while (fin.read((char *)&r, sizeof(r)))
        r.putData();

    fin.close();
}

void File::search(int id) {
    Record r;
    int flag = 0;
    fin.open("EmployeeDB");
    fin.seekg(0, ios::beg);
    while (fin.read((char *)&r, sizeof(r))) {
        if (r.getIdno() == id) {
            flag = 1;
            break;
        }
    }

    fin.close();
    if (flag == 1) {
        cout << "\nRecord Found:";
        r.putData();
    }
    else
        cout << "\nRecord not Found ";
}

int File::Delete(int id) {
    Record r;
    int flag = 0;
    fin.open("EmployeeDB");
    fout.open("Temp", ios::ate | ios::app);
    fin.seekg(0, ios::beg);
    while (fin.read((char *)&r, sizeof(r))) {
        if (r.getIdno() == id) {
            flag = 1;
        }
        else {
            fout.write((char *)&r, sizeof(r));
        }
    }
    fin.close();
    fout.close();
    remove("EmployeeDB");
    rename("Temp", "EmployeeDB");
    return (flag);
}

int File::edit(int id) {
    Record r;
    int flag = 0;
    fs.open("EmployeeDB");
    fs.seekg(0, ios::beg);
    while (fs.read((char *)&r, sizeof(r))) {
        if (r.getIdno() == id) {
            flag = 1;
            cout << "\nEnter New Details: ";
            r.getData();
            fs.seekp((int)fs.tellg() - sizeof(r), ios::beg);
            fs.write((char *)&r, sizeof(r));
        }
    }
    fs.close();
    return (flag);
}

int main() {
    File f;
    int ch, n, i, flag = 0;
    do {
        cout << "\n\n\t-----M E N U-----";
        cout << "\n\n1. Build A Master Table";
        cout << "\n2. List A Table";
        cout << "\n3. Insert a New Entry";
        cout << "\n4. Delete Old Entry";
        cout << "\n5. Edit an Entry";
        cout << "\n6. Search for a Record";
        cout << "\n7. Quit";
        cout << "\nEnter your Choice: ";
        cin >> ch;
        switch (ch) {
            case 1:
                if (flag == 0) {
                    cout << "\nEnter No of Records to insert : ";
                    cin >> n;
                    for (i = 0; i < n; i++) {
                        f.insert();
                    }
                    flag = 1;
                }
                else {
                    cout << "\nSorry.. Table is Already build... \n If want to add record please select Insert a New Entry in option.....";
                }
                break;
            case 2:
                f.display();
                break;
            case 3:
                f.insert();
                break;
            case 4:
                cout << "\nEnter Id No of Employee Whose Record is to be Deleted: ";
                cin >> n;
                i = f.Delete(n);
                if (i == 1)
                    cout << "\nRecord Deleted Successfully";
                else
                    cout << "\nRecord not Found";
                break;
            case 5:
                cout << "\nEnter Id No of Employee Whose Record is to be Edit: ";
                cin >> n;
                i = f.edit(n);
                if (i == 1)
                    cout << "\nRecord Modified Successfully";
                else
                    cout << "\nRecord not Found";
                break;
            case 6:
                cout << "\nEnter Id No of Employee Whose Record is to be Searched: ";
                cin >> n;
                f.search(n);
                break;
            case 7:
                break;
            default:
                cout << "\nEnter Valid Choice.....";
        }
    } while (ch != 7);
    return (0);
}